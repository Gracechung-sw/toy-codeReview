// (4) 거의 다 왔다고 하니, (1)에서 개선해 보기로 함  // let a = [ 2, 1, 3, 8, 31, 11, 4, -6, 0, 7 ];  // let b = [ 0, 1, 2, 3, 4 ]
// bubbleSort(a) : 끝에서 하나씩 줄여가면서 배열을 9번 탐색한다.
// bubbleSort(b) : 이미 정렬된 상태이므로, while 반복문이 한번만 실행되고, break로 가서 끝남.
// let c = [ 0, 1, 2, 4, 3 ] : 첫번째 정렬에서 4와 3을 정렬해 주고, 다음번 정렬 탐색 후 끝남.
const bubbleSort = function (array) {
  // TODO: Your code here!
  let checkpoint = array.length; // 가령, 지금은 10 -> 한바퀴 돌고 나면, 이 값을 하나 줄이고, 또 돌린다.
  // 위 배열이라면, (1) 방식으로는 시간복잡도가 n제곱쯤 될것같은데(시간복잡도를 정확한 계산을 어떻게 하는지 모르겠음)
  // 이번의 (4) 방식으로는 n 정도가 아닐까? (여기도 정확히 계산하는 법을 모르겠음. 대강 뇌피셜임)
  // 재귀와 반복문 사이를 손쉽게 오고가는 것에 숙달되어야 한다.
  // Advanced 요구조건과 Nightmare 요구조건 중, (4) 코드는 어디까지 온 것일까? - 기본보다는 나아지지 않았을까?
  while (checkpoint > 0) {
    let sortedTime = 0; // 정렬 처리를 거쳤는지 안거쳤는지를 판단하기 위한 변수. 정렬을 실행했다면 224번째 줄에서 이 값이 올라가게 됨.
    for (i = 0; i < checkpoint - 1; i++) {
      if (array[i] > array[i + 1]) {
        // 앞의 값이 뒤의 값보다 크다면, (정렬이 필요하다면,)
        let before = array[i];
        let after = array[i + 1];
        array[i] = after;
        array[i + 1] = before;
        sortedTime++; // 한번도 정렬을 실행하지 않았다면, 즉 이미 정렬되었다면, 여기로 오지 않을 것임. (그러면 기존에 주어진 0이 변경되지 않고 유지됨)
      } // 그러면 밑의 break로 들어가서 함수가 끝난다
    }
    if (sortedTime === 0) {
      // 위의 정렬 for문을 한바퀴 다 돌았는데, 그 안의 if로 한번도 들어가지 않았다면, (정렬을 할 필요가 없었다면,)
      break; // while 반복문의 실행을 중단해라 (더이상 정렬할 필요가 없으니까, while 반복문을 더 돌릴 필요가 없다.)
    }
    checkpoint = checkpoint - 1; // 한번 정렬할때마다 최소한 배열 안의 가장 큰 값 1개는 가장 뒤로 정렬되므로, 다음번 정렬에서는 끝까지 갈 필요가 없다.
  } // 그러므로 다음번의 정렬 if문에서 맨 뒤의 값까지 가지 않도록, 여기서 하나 빼 준다.

  return array; // 이렇게 하면 매개변수로 주어진 array 자체가 변경되는데, 이렇게 해도 될까?
  // 기존꺼는 건드리지 않고, 정렬된 새로운 배열을 반환해야 한다면, 코드를 수정해야 할 듯.
};
